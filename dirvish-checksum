#!/usr/bin/perl
use strict;
use warnings;
# version:  20120422
# finds files in directory and MD5sums and SHA1sums them, being smart enough to
# check against previous backup for hard links
#
#
#
#
# Copyright (C) 2008-2012  Glen Pitt-Pladdy
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#
# See http://www.pitt-pladdy.com/blog/_20120412-224240_0100_dirvish-checksum_available_again/


use Cwd;

# default config file
my $CONFIG = "/etc/dirvish/master.conf";

my $MD5SUM = "/usr/bin/md5sum";
my $SHA1SUM = "/usr/bin/sha1sum";
my $GZIP = "/bin/gzip";
my $BZIP2 = "/bin/bzip2";
my $FIND = "/usr/bin/find";



# arguments accepted:
#	--nosha1	disables SHA1SUMS
#	--nomd5		disables MD5SUMS
#	--config=<path>		alternate config file to use
#	--debug		prints extra info for debugging
#
# By default we generate SHA1 and MD5 checksums

# get command line args
my %args;
foreach my $arg (@ARGV) {
	if ( $arg =~ /^--([^\-=]+)$/ ) {
		# true value
		$args{$1} = 1;
	} elsif ( $arg =~ /^--([^\-=]+)=([^=]+)$/ ) {
		# specified value
		$args{$1} = $2;
	}
}
# check for "stupid users"
if ( $args{'nosha1'} and $args{'nomd5'} ) {
	die "This is completely pointless - I give up!\n";
}


# read the master config
my %banks;
if ( -f $CONFIG ) {
	readconfig ( $CONFIG, \%banks );
}
# read the config file and get the bank parameter
if ( $args{'config'} ) {
	readconfig ( $args{'config'}, \%banks );
}
if ( keys %banks == 0 ) { die "FATAL: no bank found in config \"$CONFIG\"\n"; }



# go through each vault in each bank
foreach my $bank (keys %banks) {
	opendir LSV, $bank or die "FATAL: can't list vaults: $!\n";
	while ( defined ( my $vault = readdir LSV ) ) {
		if ( ! -d "$bank/$vault" or $vault =~ /^\./ ) { next; }
		# check each valut for days
		opendir LSD, "$bank/$vault"
			or die "FATAL: can't list vault \"$vault\": $!\n";
		my @days;
		while ( defined ( my $day = readdir LSD ) ) {
			if ( ! -d "$bank/$vault/$day" or $day !~ /^\d{8}$/ ) { next; }
			push @days, $day;
		}
		closedir LSD;
		my $previousday;
		foreach my $day (sort @days) {
			# skip if existing checksums
			if ( -f "$bank/$vault/$day/MD5SUMS.bz2"
				and -f "$bank/$vault/$day/SHA1SUMS.bz2" ) {
				if ( $args{'debug'} ) { print "$bank/$vault/$day\n\texisting checksums\n"; }
			} else {
				# check this directory
				if ( $previousday ) {
					process_dir ( "$bank/$vault/$day",
							"$bank/$vault/$previousday" );
				} else {
					process_dir ( "$bank/$vault/$day" );
				}
			}
			# setup for next time round
			$previousday = $day;
		}
	}
	closedir LSV;
}










sub readconfig {
	my ( $config, $banks ) = @_;
	open CONF, $config or die "FATAL: can't read \"$config\": $!\n";
	my $bankfound = 0;
	while ( defined ( my $line = <CONF> ) ) {
		chomp $line;
		if ( $line =~ s/^bank:\s*// ) {
			$bankfound = 1;
			chomp $line;
			if ( $line ne '' and -d $line ) { $$banks{$line} = 1; }
		} elsif ( $bankfound and $line =~ s/^\s+// ) {
			chomp $line;
			if ( $line ne '' and -d $line ) { $$banks{$line} = 1; }
		} else {
			$bankfound = 0;
		}
	}
	close CONF;
}




# generate checksums for specified directory (getting from previous if
# hard linked)
sub process_dir {
	my $dir = shift;
	my $previousdir = shift;
	# hashes for storing inodes / checksums
	my %checksums;
	my %inodesbyfileprev;
	my %inodesbyfilenew;
	# announce where we are working
	print "$dir\n";
	# read inodeinfo from indexes if available
	if ( $previousdir and -f "$previousdir/index.gz" and -f "$previousdir/summary" ) {
		# read in the summary if available
		my $tree;
		open SMRY, '<', "$previousdir/summary"
			or die "FATAL: can't read \"$previousdir/summary\": $!\n";
		while ( defined ( my $line = <SMRY> ) ) {
			chomp $line;
			if ( $line =~ /^tree:\s+([^\s].*)$/ ) {
				$tree = $1;
				last;
			}
		}
		close SMRY;
		# read in index
		open IDX, '-|', "$GZIP -d <\"$previousdir/index.gz\""
			or die "FATAL: can't process \"$GZIP -d <\"$previousdir/index.gz\"\": $!\n";
		print "\tReading Previous index....\n";
		my $count = 0;
		while ( defined ( my $line = <IDX> ) ) {
			chomp $line;
			if ( $line =~ /^(\d+)\s+\d+\s+[\-][rwxsStT\-]+\s+\d+\s+[^\s]+\s+[^\s]+\s+\d+\s+\w+\s+\d+\s+(\d+:)?\d+\s+([^\s].+)$/ ) {
				my ( $inode, $file ) = ( $1, $3 );
				if ( substr ( $file, 0, length $tree ) eq $tree ) {
					$file = substr $file, length $tree;
					$file =~ s/^\/*/.\//;
				} else {
					next;
				}
				$file =~ s/([^\\]) .*+$/$1/;	# clear everything after a real space
				$file =~ s/\\ / /g;		# convert spaces
				$file =~ s/\\"/"/g;		# convert quotes
				$file =~ s/\\\\/\\/g;		# convert backslashes
				$file =~ s/\\(\d{3})/pack('C',oct($1))/eg;
#				if ( ! -e "$previousdir/tree/$file" ) { next; }
				++$count;
				if ( $count % 2**int(log($count)) == 0 and (stat "$previousdir/tree/$file")[1] != $inode ) {
					# validation of this inode failed - can't depend on this data
					warn "Validation of \"$previousdir/index.gz\" failed on \"$file\"\n";
					undef %inodesbyfileprev;
					last;
				} else {
					# cache inodes by file to save time later
					$inodesbyfileprev{$file} = $inode;
				}
			}
		}
		close IDX;
	}
	if ( $dir and -f "$dir/index.gz" ) {
		# read in the summary if available
		my $tree;
		open SMRY, '<', "$dir/summary"
			or die "FATAL: can't read \"$dir/summary\": $!\n";
		while ( defined ( my $line = <SMRY> ) ) {
			chomp $line;
			if ( $line =~ /^tree:\s+([^\s].*)$/ ) {
				$tree = $1;
				last;
			}
		}
		close SMRY;
		# read in index
		open IDX, '-|', "$GZIP -d <\"$dir/index.gz\""
			or die "FATAL: can't process \"$GZIP -d <\"$dir/index.gz\"\": $!\n";
		print "\tReading New index....\n";
		my $count = 0;
		while ( defined ( my $line = <IDX> ) ) {
			chomp $line;
			if ( $line =~ /^(\d+)\s+\d+\s+[\-][rwxsStT\-]+\s+\d+\s+[^\s]+\s+[^\s]+\s+\d+\s+\w+\s+\d+\s+(\d+:)?\d+\s+([^\s].+)$/ ) {
				my ( $inode, $file ) = ( $1, $3 );
				if ( substr ( $file, 0, length $tree ) eq $tree ) {
					$file = substr $file, length $tree;
					$file =~ s/^\/*/.\//;
				} else {
					next;
				}
				$file =~ s/([^\\]) .*+$/$1/;	# clear everything after a real space
				$file =~ s/\\ / /g;		# convert spaces
				$file =~ s/\\"/"/g;		# convert quotes
				$file =~ s/\\\\/\\/g;		# convert backslashes
				$file =~ s/\\(\d{3})/pack('C',oct($1))/eg;
#				if ( ! -e "$previousdir/tree/$file" ) { next; }
				++$count;
				if ( $count % 2**int(log($count)) == 0 and (stat "$dir/tree/$file")[1] != $inode ) {
					# validation of this inode failed - can't depend on this data
					warn "Validation of \"$dir/index.gz\" failed on \"$file\"\n";
					undef %inodesbyfilenew;
					last;
				} else {
					# cache inodes by file to save time later
					$inodesbyfilenew{$file} = $inode;
				}
			}
		}
		close IDX;
	}
	# get checksums for previous files based on SHA1SUMS
	if ( $previousdir and -f "$previousdir/SHA1SUMS.bz2"
		and ! -f "$dir/SHA1SUMS.bz2" and ! $args{'nosha1'} ) {
		print "\tgetting checksums/inodes for previous SHA1SUMS....\n";
		open SHA1, "$BZIP2 -d <\"$previousdir/SHA1SUMS.bz2\"|"
			or die "FATAL: can't process \"$BZIP2 -d <\"$previousdir/SHA1SUMS.bz2\"\": $!\n";
		while ( defined ( my $line = <SHA1> ) ) {
			chomp $line;
			if ( $line =~ /^(\w+)\s+([^\s].+)$/ ) {
				my $inode;
				my ( $checksum, $path ) = ( $1, $2 );
				$path =~ s/^\//.\//;
				# use cached inodes if available
				if ( exists $inodesbyfileprev{$path} ) {
					$inode = $inodesbyfileprev{$path};
				} else {
					$inode = (stat "$previousdir/tree/$path")[1];
					# cache inodes by file to save time later
					$inodesbyfileprev{$path} = $inode;
				}
				if ( ! $inode ) {
					print STDERR "\tWARNING: no inode for \"$previousdir/tree/$path\"\n";
					next;
				}
				$checksums{$inode} = $checksum;
			}
		}
		close SHA1;
	}
	# sha1sum tree
	if ( ! -f "$dir/SHA1SUMS.bz2" and ! $args{'nosha1'} ) {
		print "\tgenerating checksums....\n";
		my $pwd = getcwd;
		if ( ! chdir "$dir/tree" ) {
			print STDERR "\tWARNING: can't change directory to \"$dir/tree\": $!\n";
			return 1;
		}
#		open FND, "$FIND -type f |"
#				or die "FATAL: can't run find: $!\n";
		open SHA1, '|-', "bzip2 >$dir/SHA1SUMS.bz2.TMP"
				or die "FATAL: can't write \"bzip2 >$dir/SHA1SUMS.bz2.TMP\": $!\n";
		my $filecount = 0;
		my $fileduplicate = 0;
#		while ( defined ( my $line = <FND> ) ) {
		foreach my $line (keys %inodesbyfilenew) {
#			chomp $line;
			++$filecount;
			my $inode;
			if ( exists $inodesbyfilenew{$line} ) {
				$inode = $inodesbyfilenew{$line};
			} else {
				$inode = (stat $line)[1];
				$inodesbyfilenew{$line} = $inode;
			}
			if ( $checksums{$inode} ) {
				print SHA1 "$checksums{$inode}  $line\n";
				++$fileduplicate
			} else {
				# sha1sum file
				my $file = $line;
				$file =~ s/\\/\\\\/g;
				$file =~ s/"/\\"/g;
				$file =~ s/`/\\`/g;
				$file =~ s/\$/\\\$/g;
				my $sha1 = `$SHA1SUM "$file"`;
				chomp $sha1;
				if ( $sha1 eq "" ) { print "ERROR:  \"$file\"\n"; }
				print SHA1 "$sha1\n";
			}
		}
#		close FND;
		close SHA1;
		chdir $pwd;
		# replace the SHA1SUMS
		rename "$dir/SHA1SUMS.bz2.TMP", "$dir/SHA1SUMS.bz2";
		# stats
		if ( $filecount == 0 ) {
			print "\t\tWARNING:  No files found\n";
		} else {
			printf "\t\thard linked %.1f %%\n", 100 * $fileduplicate / $filecount;
		}
	}
	# clear for next round
	undef %checksums;
	# get checksums for previous files based on MD5SUMS
	if ( $previousdir and -f "$previousdir/MD5SUMS.bz2"
		and ! -f "$dir/MD5SUMS.bz2" and ! $args{'nomd5'} ) {
		print "\tgetting checksums/inodes for previous MD5SUMS....\n";
		open MD5, "$BZIP2 -d <\"$previousdir/MD5SUMS.bz2\"|"
			or die "FATAL: can't process \"$BZIP2 -d <\"$previousdir/MD5SUMS.bz2\"\": $!\n";
		while ( defined ( my $line = <MD5> ) ) {
			chomp $line;
			if ( $line =~ /^(\w+)\s+([^\s].+)$/ ) {
				my $inode;
				my ( $checksum, $path ) = ( $1, $2 );
				$path =~ s/^\//.\//;
				# use cached inodes if available
				if ( exists $inodesbyfileprev{$path} ) {
					$inode = $inodesbyfileprev{$path};
				} else {
					$inode = (stat "$previousdir/tree/$path")[1];
					# cache inodes by file to save time later
					$inodesbyfileprev{$path} = $inode;
				}
				if ( ! $inode ) {
					print STDERR "\tWARNING: no inode for \"$previousdir/tree/$path\"\n";
					next;
				}
				$checksums{$inode} = $checksum;
			}
		}
		close MD5;
	}
	# md5sum tree
	if ( ! -f "$dir/MD5SUMS.bz2" and ! $args{'nomd5'} ) {
		print "\tgenerating checksums....\n";
		my $pwd = getcwd;
		if ( ! chdir "$dir/tree" ) {
			print STDERR "\tWARNING: can't change directory to \"$dir/tree\": $!\n";
			return 1;
		}
#		open FND, "$FIND -type f |"
#				or die "FATAL: can't run find: $!\n";
		open MD5, '|-', "bzip2 >$dir/MD5SUMS.bz2.TMP"
				or die "FATAL: can't write \"bzip2 >$dir/MD5SUMS.bz2.TMP\": $!\n";
		my $filecount = 0;
		my $fileduplicate = 0;
#		while ( defined ( my $line = <FND> ) ) {
		foreach my $line (keys %inodesbyfilenew) {
#			chomp $line;
			++$filecount;
			my $inode;
			if ( exists $inodesbyfilenew{$line} ) {
				$inode = $inodesbyfilenew{$line};
			} else {
				$inode = (stat $line)[1];
				$inodesbyfilenew{$line} = $inode;
			}
			if ( $checksums{$inode} ) {
				print MD5 "$checksums{$inode}  $line\n";
				++$fileduplicate
			} else {
				# md5sum file
				my $file = $line;
				$file =~ s/\\/\\\\/g;
				$file =~ s/`/\\`/g;
				$file =~ s/"/\\"/g;
				$file =~ s/\$/\\\$/g;
				my $md5 = `$MD5SUM "$file"`;
				chomp $md5;
				if ( $md5 eq "" ) { print "ERROR:  \"$file\"\n"; }
				print MD5 "$md5\n";
			}
		}
#		close FND;
		close MD5;
		chdir $pwd;
		# replace the MD5SUMS
		rename "$dir/MD5SUMS.bz2.TMP", "$dir/MD5SUMS.bz2";
		# stats
		if ( $filecount == 0 ) {
			print "\t\tWARNING:  No files found\n";
		} else {
			printf "\t\thard linked %.1f %%\n", 100 * $fileduplicate / $filecount;
		}
	}
	# replace the inodes
	rename "$dir/inodes.bz2.TMP", "$dir/inodes.bz2";
}



