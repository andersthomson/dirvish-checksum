#!/usr/bin/perl
use strict;
use warnings;
# version:  20120413
# finds files in directory and MD5sums and SHA1sums them, being smart enough to
# check against previous backup for hard links
#
#
#
#
# Copyright (C) 2008-2012  Glen Pitt-Pladdy
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#

use Cwd;

# default config file
my $CONFIG = "/etc/dirvish/master.conf";

my $MD5SUM = "/usr/bin/md5sum";
my $SHA1SUM = "/usr/bin/sha1sum";
my $BZIP2 = "/bin/bzip2";
my $FIND = "/usr/bin/find";



# arguments accepted:
#	--nosha1	disables SHA1SUMS
#	--nomd5		disables MD5SUMS
#	--config=<path>		alternate config file to use
#	--debug		prints extra info for debugging
#
# By default we generate SHA1 and MD5 checksums

# get command line args
my %args;
foreach my $arg (@ARGV) {
	if ( $arg =~ /^--([^\-=]+)$/ ) {
		# true value
		$args{$1} = 1;
	} elsif ( $arg =~ /^--([^\-=]+)=([^=]+)$/ ) {
		# specified value
		$args{$1} = $2;
	}
}
# check for "stupid users"
if ( $args{'nosha1'} and $args{'nomd5'} ) {
	die "This is completely pointless - I give up!\n";
}


# read the master config
my %banks;
if ( -f $CONFIG ) {
	readconfig ( $CONFIG, \%banks );
}
# read the config file and get the bank parameter
if ( $args{'config'} ) {
	readconfig ( $args{'config'}, \%banks );
}
if ( keys %banks == 0 ) { die "FATAL: no bank found in config \"$CONFIG\"\n"; }



# go through each vault in each bank
foreach my $bank (keys %banks) {
	opendir LSV, $bank or die "FATAL: can't list vaults: $!\n";
	while ( defined ( my $vault = readdir LSV ) ) {
		if ( ! -d "$bank/$vault" or $vault =~ /^\./ ) { next; }
		# check each valut for days
		opendir LSD, "$bank/$vault"
			or die "FATAL: can't list vault \"$vault\": $!\n";
		my @days;
		while ( defined ( my $day = readdir LSD ) ) {
			if ( ! -d "$bank/$vault/$day" or $day !~ /^\d{8}$/ ) { next; }
			push @days, $day;
		}
		closedir LSD;
		my $previousday;
		foreach my $day (sort @days) {
			# skip if existing checksums
			if ( -f "$bank/$vault/$day/MD5SUMS.bz2"
				and -f "$bank/$vault/$day/SHA1SUMS.bz2" ) {
				if ( $args{'debug'} ) { print "$bank/$vault/$day\n\texisting checksums\n"; }
			} else {
				# check this directory
				if ( $previousday ) {
					process_dir ( "$bank/$vault/$day",
							"$bank/$vault/$previousday" );
				} else {
					process_dir ( "$bank/$vault/$day" );
				}
			}
			# setup for next time round
			$previousday = $day;
		}
	}
	closedir LSV;
}










sub readconfig {
	my ( $config, $banks ) = @_;
	open CONF, $config or die "FATAL: can't read \"$config\": $!\n";
	my $bankfound = 0;
	while ( defined ( my $line = <CONF> ) ) {
		chomp $line;
		if ( $line =~ s/^bank:\s*// ) {
			$bankfound = 1;
			chomp $line;
			if ( $line ne '' and -d $line ) { $$banks{$line} = 1; }
		} elsif ( $bankfound and $line =~ s/^\s+// ) {
			chomp $line;
			if ( $line ne '' and -d $line ) { $$banks{$line} = 1; }
		} else {
			$bankfound = 0;
		}
	}
	close CONF;
}




# generate checksums for specified directory (getting from previous if
# hard linked)
sub process_dir {
	my $dir = shift;
	my $previousdir = shift;
	# hashes for storing inodes / checksums
	my %checksums;
	my %inodesbyfile;
	my %inodesbyfilenew;
	# announce where we are working
	print "$dir\n";
	# read inode cache if available
	if ( $previousdir and -f "$previousdir/inodes.bz2" ) {
		open INO, '-|', "$BZIP2 -d <\"$previousdir/inodes.bz2\""
			or die "FATAL: can't process \"$BZIP2 -d <\"$previousdir/inodes.bz2\"\": $!\n";
		my $count = 0;
		while ( defined ( my $line = <INO> ) ) {
			chomp $line;
			if ( $line =~ /^(\d+)\s+([^\s].+)$/ ) {
				if ( $count++ % 1000 == 0 and (stat "$previousdir/tree/$2")[1] != $1 ) {
					# validation of this inode failed - can't depend on this data
					warn "Validation of \"$previousdir/inodes.bz2\" failed on \"$2\"\n";
					undef %inodesbyfile;
					last;
				} else {
					# cache inodes by file to save time later
					$inodesbyfile{$2} = $1;
				}
			}
		}
		close SHA1;
	}
	# get inodes for previous files based on SHA1SUMS
	if ( $previousdir and -f "$previousdir/SHA1SUMS.bz2"
		and ! -f "$dir/SHA1SUMS.bz2" and ! $args{'nosha1'} ) {
		print "\tgetting checksums/inodes for previous SHA1SUMS....\n";
		open SHA1, "$BZIP2 -d <\"$previousdir/SHA1SUMS.bz2\"|"
			or die "FATAL: can't process \"$BZIP2 -d <\"$previousdir/SHA1SUMS.bz2\"\": $!\n";
		while ( defined ( my $line = <SHA1> ) ) {
			chomp $line;
			if ( $line =~ /^(\w+)\s+([^\s].+)$/ ) {
				my $inode;
				# use cached inodes if available
				if ( $inodesbyfile{$2} ) {
					$inode = $inodesbyfile{$2};
				} else {
					$inode = (stat "$previousdir/tree/$2")[1];
				}
				if ( ! $inode ) {
					print STDERR "\tWARNING: no inode for \"$previousdir/tree/$2\"\n";
					next;
				}
				$checksums{$inode} = $1;
				# cache inodes by file to save time later
				$inodesbyfile{$2} = $inode;
			}
		}
		close SHA1;
	}
	# sha1sum tree
	if ( ! -f "$dir/SHA1SUMS.bz2" and ! $args{'nosha1'} ) {
		print "\tgenerating checksums....\n";
		my $pwd = getcwd;
		if ( ! chdir "$dir/tree" ) {
			print STDERR "\tWARNING: can't change directory to \"$dir/tree\": $!\n";
			return 1;
		}
		open FND, "$FIND -type f |"
				or die "FATAL: can't run find: $!\n";
		open SHA1, '|-', "bzip2 >$dir/SHA1SUMS.bz2.TMP"
				or die "FATAL: can't write \"bzip2 >$dir/SHA1SUMS.bz2.TMP\": $!\n";
		my $filecount = 0;
		my $fileduplicate = 0;
		while ( defined ( my $line = <FND> ) ) {
			chomp $line;
			++$filecount;
			my $inode;
			if ( exists $inodesbyfilenew{$line} ) {
				$inode = $inodesbyfilenew{$line};
			} else {
				$inode = (stat $line)[1];
				$inodesbyfilenew{$line} = $inode;
			}
			if ( $checksums{$inode} ) {
				print SHA1 "$checksums{$inode}  $line\n";
				++$fileduplicate
			} else {
				# sha1sum file
				my $file = $line;
				$file =~ s/\\/\\\\/g;
				$file =~ s/"/\\"/g;
				$file =~ s/`/\\`/g;
				$file =~ s/\$/\\\$/g;
				my $sha1 = `$SHA1SUM "$file"`;
				chomp $sha1;
				if ( $sha1 eq "" ) { print "ERROR:  \"$file\"\n"; }
				print SHA1 "$sha1\n";
			}
		}
		close FND;
		close SHA1;
		chdir $pwd;
		# replace the SHA1SUMS
		rename "$dir/SHA1SUMS.bz2.TMP", "$dir/SHA1SUMS.bz2";
		# stats
		if ( $filecount == 0 ) {
			print "\t\tWARNING:  No files found\n";
		} else {
			printf "\t\thard linked %.1f %%\n", 100 * $fileduplicate / $filecount;
		}
	}
	# clear for next round
	undef %checksums;
	# get inodes for previous files based on MD5SUMS
	if ( $previousdir and -f "$previousdir/MD5SUMS.bz2"
		and ! -f "$dir/MD5SUMS.bz2" and ! $args{'nomd5'} ) {
		print "\tgetting checksums/inodes for previous MD5SUMS....\n";
		open MD5, "$BZIP2 -d <\"$previousdir/MD5SUMS.bz2\"|"
			or die "FATAL: can't process \"$BZIP2 -d <\"$previousdir/MD5SUMS.bz2\"\": $!\n";
		while ( defined ( my $line = <MD5> ) ) {
			chomp $line;
			if ( $line =~ /^(\w+)\s+([^\s].+)$/ ) {
				my $inode;
				# use cached inodes if available
				if ( $inodesbyfile{$2} ) {
					$inode = $inodesbyfile{$2};
				} else {
					$inode = (stat "$previousdir/tree/$2")[1];
				}
				if ( ! $inode ) {
					print STDERR "\tWARNING: no inode for \"$previousdir/tree/$2\"\n";
					next;
				}
				$checksums{$inode} = $1;
				# cache inodes by file to save time later
				$inodesbyfile{$2} = $inode;
			}
		}
		close MD5;
	}
	# md5sum tree
	if ( ! -f "$dir/MD5SUMS.bz2" and ! $args{'nomd5'} ) {
		print "\tgenerating checksums....\n";
		my $pwd = getcwd;
		if ( ! chdir "$dir/tree" ) {
			print STDERR "\tWARNING: can't change directory to \"$dir/tree\": $!\n";
			return 1;
		}
		open FND, "$FIND -type f |"
				or die "FATAL: can't run find: $!\n";
		open MD5, '|-', "bzip2 >$dir/MD5SUMS.bz2.TMP"
				or die "FATAL: can't write \"bzip2 >$dir/MD5SUMS.bz2.TMP\": $!\n";
		my $filecount = 0;
		my $fileduplicate = 0;
		while ( defined ( my $line = <FND> ) ) {
			chomp $line;
			++$filecount;
			my $inode;
			if ( exists $inodesbyfilenew{$line} ) {
				$inode = $inodesbyfilenew{$line};
			} else {
				$inode = (stat $line)[1];
				$inodesbyfilenew{$line} = $inode;
			}
			if ( $checksums{$inode} ) {
				print MD5 "$checksums{$inode}  $line\n";
				++$fileduplicate
			} else {
				# md5sum file
				my $file = $line;
				$file =~ s/\\/\\\\/g;
				$file =~ s/`/\\`/g;
				$file =~ s/"/\\"/g;
				$file =~ s/\$/\\\$/g;
				my $md5 = `$MD5SUM "$file"`;
				chomp $md5;
				if ( $md5 eq "" ) { print "ERROR:  \"$file\"\n"; }
				print MD5 "$md5\n";
			}
		}
		close FND;
		close MD5;
		chdir $pwd;
		# replace the MD5SUMS
		rename "$dir/MD5SUMS.bz2.TMP", "$dir/MD5SUMS.bz2";
		# stats
		if ( $filecount == 0 ) {
			print "\t\tWARNING:  No files found\n";
		} else {
			printf "\t\thard linked %.1f %%\n", 100 * $fileduplicate / $filecount;
		}
	}
	# store inode cache
	open INO, '|-', "bzip2 >$dir/inodes.bz2.TMP"
		or die "FATAL: can't write \"bzip2 >$dir/inodes.bz2.TMP\": $!\n";
	foreach my $file (keys %inodesbyfilenew) {
		print INO "$inodesbyfilenew{$file}  $file\n";
	}
	close INO;
	# replace the inodes
	rename "$dir/inodes.bz2.TMP", "$dir/inodes.bz2";
}



